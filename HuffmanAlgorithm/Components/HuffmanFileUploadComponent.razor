@using HuffmanAlgorithm.Services
@using HuffmanAlgorithm.Interfaces
@using HuffmanAlgorithm.Models
@inject IHuffmanEncoderService HuffmanEncoderService
@inject HuffmanProcessingData _huffmanProcessingData
@implements IDisposable

<div class="huffman-upload-file-component-wrapper">
    <h4 class="upload-title">Upload File for Huffman Coding</h4>

    <InputFile OnChange="UploadFileAsync" />
    <br />

    <button @onclick="ProcessTextFile" disabled="@(selectedFile == null || !IsTextFile)">Code Text File</button>
    <br />

    <button @onclick="ProcessImageFile" disabled="@(selectedFile == null || !IsImageFile)">Code Image File</button>
    <br />

    <button @onclick="ProcessBinaryFile" disabled="@(selectedFile == null || IsImageFile || IsTextFile)">Code Binary File</button>

    @if (!string.IsNullOrEmpty(encodedBits))
    {
        <div>
            <h5>Encoded Binary Data:</h5>
            <pre>@encodedBits</pre>
        </div>
    }

</div>

@if (_huffmanProcessingData.IsPending)
{
    <p>Trwa kodowanie...</p>
}

@code {
    private string encodedBits = "";
    private string? encodedFileText = null;
    private IBrowserFile? selectedFile;

    private bool IsTextFile
    {
        get
        {
            var fileName = selectedFile?.Name;
            Console.WriteLine($"Checking if file is text file: {fileName}");
            return !string.IsNullOrEmpty(fileName) &&
                   (fileName.EndsWith(".txt", StringComparison.OrdinalIgnoreCase));
        }
    }

    private bool IsImageFile
    {
        get
        {
            var fileName = selectedFile?.Name;
            Console.WriteLine($"Checking if file is image file: {fileName}");
            return !string.IsNullOrEmpty(fileName) &&
                   (fileName.EndsWith(".jpg", StringComparison.OrdinalIgnoreCase) ||
                    fileName.EndsWith(".jpeg", StringComparison.OrdinalIgnoreCase) ||
                    fileName.EndsWith(".png", StringComparison.OrdinalIgnoreCase) ||
                    fileName.EndsWith(".gif", StringComparison.OrdinalIgnoreCase));
        }
    }

    private void ProcessTextFile()
    {
        Console.WriteLine("Starting text file processing...");

        if (encodedFileText == null)
        {
            if (!string.IsNullOrEmpty(_huffmanProcessingData.InputText))
            {
                Console.WriteLine($"InputText: {_huffmanProcessingData.InputText}");
                HuffmanEncoderService.EncodeText();
                encodedFileText = _huffmanProcessingData.EncodedText;
                Console.WriteLine($"EncodedText: {encodedFileText}");
            }
            else
            {
                encodedFileText = "Please upload a valid text file.";
                Console.WriteLine(encodedFileText);
            }
        }
    }

    private async Task ProcessImageFile()
    {
        Console.WriteLine("Starting image file processing...");

        if (selectedFile != null && IsImageFile)
        {
            Console.WriteLine($"File selected for image processing: {selectedFile.Name}");
            var imageBytes = await ReadFileAsBytesAsync(selectedFile);
            Console.WriteLine($"Image file read, size: {imageBytes.Length} bytes.");

            try
            {
                _huffmanProcessingData.InputText = Convert.ToBase64String(imageBytes);
                Console.WriteLine($"Encoded image data (Base64): {_huffmanProcessingData.InputText}");

                HuffmanEncoderService.EncodeText(); 
                encodedFileText = _huffmanProcessingData.EncodedText; 
                Console.WriteLine($"EncodedText: {encodedFileText}");
            }
            catch (Exception ex)
            {
                encodedFileText = $"Error during encoding: {ex.Message}";
                Console.WriteLine(encodedFileText);
            }
        }
    }

    private async Task ProcessBinaryFile()
    {
        Console.WriteLine("Starting binary file processing...");

        if (selectedFile != null)
        {
            Console.WriteLine($"File selected for binary processing: {selectedFile.Name}");
            var byteArray = await ReadFileAsBytesAsync(selectedFile);

            Console.WriteLine($"Binary file read, size: {byteArray.Length} bytes.");

            if (byteArray.Length == 0)
            {
                encodedFileText = "Failed to read binary file or file is empty.";
                Console.WriteLine(encodedFileText);
                return;
            }

            try
            {
                _huffmanProcessingData.InputText = Convert.ToBase64String(byteArray);
                Console.WriteLine($"Encoded binary data (Base64): {_huffmanProcessingData.InputText}");

            
                HuffmanEncoderService.EncodeText(); 
                encodedFileText = _huffmanProcessingData.EncodedText; 
                Console.WriteLine($"EncodedText: {encodedFileText}");
            }
            catch (Exception ex)
            {
                encodedFileText = $"Error during encoding: {ex.Message}";
                Console.WriteLine(encodedFileText);
            }
        }
    }


    private async Task<byte[]> ReadFileAsBytesAsync(IBrowserFile file)
    {
        try
        {
            using var stream = file.OpenReadStream();
            using var memoryStream = new MemoryStream();
            await stream.CopyToAsync(memoryStream);
            Console.WriteLine($"Read file as bytes, size: {memoryStream.Length}");
            return memoryStream.ToArray();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading file: {ex.Message}");
            encodedFileText = $"Error reading file: {ex.Message}";
            return Array.Empty<byte>();
        }
    }

    private async Task ReadFileAsTextAsync(IBrowserFile file)
    {
        try
        {
            using var stream = file.OpenReadStream();
            using var reader = new StreamReader(stream);
            _huffmanProcessingData.InputText = await reader.ReadToEndAsync();
            Console.WriteLine($"Read file as text, length: {_huffmanProcessingData.InputText?.Length}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading text file: {ex.Message}");
        }
    }

    private async Task UploadFileAsync(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file != null)
        {
            Console.WriteLine($"File uploaded: {file.Name}");
            selectedFile = file;
            encodedFileText = null;

            if (IsTextFile)
            {
                Console.WriteLine("Processing as text file.");
                await ReadFileAsTextAsync(file);
            }
            else
            {
                Console.WriteLine("Processing as non-text file.");
                _huffmanProcessingData.InputText = null;
            }
        }
    }

    protected override void OnInitialized()
    {
        HuffmanEncoderService.OnChange += StateHasChanged;
    }

    public void Dispose()
    {
        HuffmanEncoderService.OnChange -= StateHasChanged;
    }
}
